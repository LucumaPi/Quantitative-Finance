<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<section xmlns="http://docbook.org/ns/docbook" version="5.0" xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="_classLUTridiagonalSolver">
<title>LUTridiagonalSolver&lt; V, I &gt; Class Template Reference</title>
<indexterm><primary>LUTridiagonalSolver&lt; V, I &gt;</primary></indexterm>
<para>
<computeroutput>#include &lt;LUSolver.hh&gt;</computeroutput>
</para>
Collaboration diagram for LUTridiagonalSolver&lt; V, I &gt;:<para>
    <informalfigure>
        <mediaobject>
            <imageobject>
                <imagedata width="50%" align="center" valign="middle" scalefit="0" fileref="classLUTridiagonalSolver__coll__graph.png"></imagedata>
            </imageobject>
        </mediaobject>
    </informalfigure>
</para>
<simplesect>
    <title>Public Member Functions    </title>
        <itemizedlist>
            <listitem><para><link linkend="_classLUTridiagonalSolver_1aceddcd98aa6ec424d5e537f07d87576f">LUTridiagonalSolver</link> ()</para>
</listitem>
            <listitem><para><link linkend="_classLUTridiagonalSolver_1a6819482146633c32327a2a6b9803e115">LUTridiagonalSolver</link> (<link linkend="_classVector">Vector</link>&lt; V, I &gt; &amp;lower_A, <link linkend="_classVector">Vector</link>&lt; V, I &gt; &amp;diagonal_B, <link linkend="_classVector">Vector</link>&lt; V, I &gt; &amp;upper_C, <link linkend="_classVector">Vector</link>&lt; V, I &gt; &amp;rhs_R)</para>
</listitem>
            <listitem><para><link linkend="_classLUTridiagonalSolver_1abc85aa731a341b6c8fbc5bc77c77e8a3">LUTridiagonalSolver</link> (const <link linkend="_classLUTridiagonalSolver">LUTridiagonalSolver</link>&lt; V, I &gt; &amp;source)</para>
</listitem>
            <listitem><para>virtual <link linkend="_classLUTridiagonalSolver_1a1644f4512162dc3c91f5598dc3b5caad">~LUTridiagonalSolver</link> ()</para>
</listitem>
            <listitem><para><link linkend="_classLUTridiagonalSolver">LUTridiagonalSolver</link>&lt; V, I &gt; &amp; <link linkend="_classLUTridiagonalSolver_1a2cdb62889b9371224819f07a5daf5df3">operator=</link> (const <link linkend="_classLUTridiagonalSolver">LUTridiagonalSolver</link>&lt; V, I &gt; &amp;source)</para>
</listitem>
            <listitem><para><link linkend="_classVector">Vector</link>&lt; V, I &gt; <link linkend="_classLUTridiagonalSolver_1aaa85d72ad1cd651291fee595db3fe1d8">solve</link> ()</para>
</listitem>
            <listitem><para>bool <link linkend="_classLUTridiagonalSolver_1a4cb24bdf98332a3fd46da775166ced08">diagonallyDominant</link> () const</para>
</listitem>
        </itemizedlist>
</simplesect>
<section>
<title>Detailed Description</title>
<simplesect><title>template&lt;class V, class I&gt;
class LUTridiagonalSolver&lt; V, I &gt;</title></simplesect>

<para>
Definition at line 17 of file LUSolver.hh.</para>
</section>
<section>
<title>Constructor &amp; Destructor Documentation</title>
<anchor xml:id="_classLUTridiagonalSolver_1aceddcd98aa6ec424d5e537f07d87576f"/>    <section>
    <title>LUTridiagonalSolver()<computeroutput>[1/3]</computeroutput></title>
<indexterm><primary>LUTridiagonalSolver</primary><secondary>LUTridiagonalSolver&lt; V, I &gt;</secondary></indexterm>
<indexterm><primary>LUTridiagonalSolver&lt; V, I &gt;</primary><secondary>LUTridiagonalSolver</secondary></indexterm>
<computeroutput>template&lt;class V , class I &gt; </computeroutput><para><computeroutput><link linkend="_classLUTridiagonalSolver">LUTridiagonalSolver</link>&lt; V, I &gt;::<link linkend="_classLUTridiagonalSolver">LUTridiagonalSolver</link> ( )</computeroutput></para><para>
Definition at line 78 of file LUSolver.cc.</para>
<programlisting>79 {
80 &#32;&#32;&#32;&#32;
81 &#32;&#32;&#32;&#32;a&#32;=&#32;<link linkend="_classVector">Vector&lt;V,I&gt;</link>&#32;(1);
82 &#32;&#32;&#32;&#32;<link linkend="_namespaceNSEuropeanOption_1a6b26f4d79c6b43133be664e2eb229fff">b</link>&#32;=&#32;<link linkend="_classVector">Vector&lt;V,I&gt;</link>&#32;(1);
83 &#32;&#32;&#32;&#32;c&#32;=&#32;<link linkend="_classVector">Vector&lt;V,I&gt;</link>&#32;(1);
84 &#32;&#32;&#32;&#32;<link linkend="_namespaceNSEuropeanOption_1adf476278b7e6a6960d82dc00e93ef723">r</link>&#32;=&#32;<link linkend="_classVector">Vector&lt;V,I&gt;</link>&#32;(1);
85 
86 &#32;&#32;&#32;&#32;Size&#32;=&#32;1;
87 }
</programlisting>    </section><anchor xml:id="_classLUTridiagonalSolver_1a6819482146633c32327a2a6b9803e115"/>    <section>
    <title>LUTridiagonalSolver()<computeroutput>[2/3]</computeroutput></title>
<indexterm><primary>LUTridiagonalSolver</primary><secondary>LUTridiagonalSolver&lt; V, I &gt;</secondary></indexterm>
<indexterm><primary>LUTridiagonalSolver&lt; V, I &gt;</primary><secondary>LUTridiagonalSolver</secondary></indexterm>
<computeroutput>template&lt;class V , class I &gt; </computeroutput><para><computeroutput><link linkend="_classLUTridiagonalSolver">LUTridiagonalSolver</link>&lt; V, I &gt;::<link linkend="_classLUTridiagonalSolver">LUTridiagonalSolver</link> (<link linkend="_classVector">Vector</link>&lt; V, I &gt; &amp; lower_A, <link linkend="_classVector">Vector</link>&lt; V, I &gt; &amp; diagonal_B, <link linkend="_classVector">Vector</link>&lt; V, I &gt; &amp; upper_C, <link linkend="_classVector">Vector</link>&lt; V, I &gt; &amp; rhs_R)</computeroutput></para><para>
Definition at line 89 of file LUSolver.cc.</para>
<programlisting>90 {
91 
92 &#32;&#32;&#32;&#32;a&#32;=&#32;lower;
93 &#32;&#32;&#32;&#32;<link linkend="_namespaceNSEuropeanOption_1a6b26f4d79c6b43133be664e2eb229fff">b</link>&#32;=&#32;diagonal;
94 &#32;&#32;&#32;&#32;c&#32;=&#32;upper;
95 &#32;&#32;&#32;&#32;<link linkend="_namespaceNSEuropeanOption_1adf476278b7e6a6960d82dc00e93ef723">r</link>&#32;=&#32;RHS;
96 
97 &#32;&#32;&#32;&#32;Size&#32;=&#32;diagonal.Size();
98 
99 }
</programlisting>    </section><anchor xml:id="_classLUTridiagonalSolver_1abc85aa731a341b6c8fbc5bc77c77e8a3"/>    <section>
    <title>LUTridiagonalSolver()<computeroutput>[3/3]</computeroutput></title>
<indexterm><primary>LUTridiagonalSolver</primary><secondary>LUTridiagonalSolver&lt; V, I &gt;</secondary></indexterm>
<indexterm><primary>LUTridiagonalSolver&lt; V, I &gt;</primary><secondary>LUTridiagonalSolver</secondary></indexterm>
<computeroutput>template&lt;class V , class I &gt; </computeroutput><para><computeroutput><link linkend="_classLUTridiagonalSolver">LUTridiagonalSolver</link>&lt; V, I &gt;::<link linkend="_classLUTridiagonalSolver">LUTridiagonalSolver</link> (const <link linkend="_classLUTridiagonalSolver">LUTridiagonalSolver</link>&lt; V, I &gt; &amp; source)</computeroutput></para><para>
Definition at line 101 of file LUSolver.cc.</para>
<programlisting>102 {
103 
104 &#32;&#32;&#32;&#32;a&#32;=&#32;source.a;
105 &#32;&#32;&#32;&#32;<link linkend="_namespaceNSEuropeanOption_1a6b26f4d79c6b43133be664e2eb229fff">b</link>&#32;=&#32;source.b;
106 &#32;&#32;&#32;&#32;c&#32;=&#32;source.c;
107 &#32;&#32;&#32;&#32;<link linkend="_namespaceNSEuropeanOption_1adf476278b7e6a6960d82dc00e93ef723">r</link>&#32;=&#32;source.r;
108 
109 &#32;&#32;&#32;&#32;Size&#32;=&#32;source.Size;
110 
111 }
</programlisting>    </section><anchor xml:id="_classLUTridiagonalSolver_1a1644f4512162dc3c91f5598dc3b5caad"/>    <section>
    <title>~LUTridiagonalSolver()</title>
<indexterm><primary>~LUTridiagonalSolver</primary><secondary>LUTridiagonalSolver&lt; V, I &gt;</secondary></indexterm>
<indexterm><primary>LUTridiagonalSolver&lt; V, I &gt;</primary><secondary>~LUTridiagonalSolver</secondary></indexterm>
<computeroutput>template&lt;class V , class I &gt; </computeroutput><para><computeroutput><link linkend="_classLUTridiagonalSolver">LUTridiagonalSolver</link>&lt; V, I &gt;::~<link linkend="_classLUTridiagonalSolver">LUTridiagonalSolver</link> ( )<computeroutput>[virtual]</computeroutput></computeroutput></para><para>
Definition at line 114 of file LUSolver.cc.</para>
<programlisting>115 {
116 
117 }
</programlisting></section>
</section>
<section>
<title>Member Function Documentation</title>
<anchor xml:id="_classLUTridiagonalSolver_1a4cb24bdf98332a3fd46da775166ced08"/>    <section>
    <title>diagonallyDominant()</title>
<indexterm><primary>diagonallyDominant</primary><secondary>LUTridiagonalSolver&lt; V, I &gt;</secondary></indexterm>
<indexterm><primary>LUTridiagonalSolver&lt; V, I &gt;</primary><secondary>diagonallyDominant</secondary></indexterm>
<computeroutput>template&lt;class V , class I &gt; </computeroutput><para><computeroutput>bool <link linkend="_classLUTridiagonalSolver">LUTridiagonalSolver</link>&lt; V, I &gt;::diagonallyDominant ( ) const</computeroutput></para><para>
Definition at line 147 of file LUSolver.cc.</para>
<programlisting>148 {
149 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(std::fabs(<link linkend="_namespaceNSEuropeanOption_1a6b26f4d79c6b43133be664e2eb229fff">b</link>[1])&#32;&lt;&#32;std::fabs(c[1]))
150 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">false</emphasis>;
151 
152 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(std::fabs(<link linkend="_namespaceNSEuropeanOption_1a6b26f4d79c6b43133be664e2eb229fff">b</link>[Size])&#32;&lt;&#32;std::fabs(a[Size]))
153 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">false</emphasis>;
154 
155 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(I&#32;j&#32;=&#32;2;&#32;j&#32;&lt;=&#32;Size-1;&#32;j++)
156 &#32;&#32;&#32;&#32;{
157 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(std::fabs(<link linkend="_namespaceNSEuropeanOption_1a6b26f4d79c6b43133be664e2eb229fff">b</link>[j])&#32;&lt;&#32;std::fabs(a[j])&#32;+&#32;std::fabs(c[j])&#32;)
158 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">false</emphasis>;
159 &#32;&#32;&#32;&#32;}
160 
161 &#32;&#32;&#32;&#32;
162 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">true</emphasis>;&#32;
163 }
</programlisting>    </section><anchor xml:id="_classLUTridiagonalSolver_1a2cdb62889b9371224819f07a5daf5df3"/>    <section>
    <title>operator=()</title>
<indexterm><primary>operator=</primary><secondary>LUTridiagonalSolver&lt; V, I &gt;</secondary></indexterm>
<indexterm><primary>LUTridiagonalSolver&lt; V, I &gt;</primary><secondary>operator=</secondary></indexterm>
<computeroutput>template&lt;class V , class I &gt; </computeroutput><para><computeroutput><link linkend="_classLUTridiagonalSolver">LUTridiagonalSolver</link>&lt; V, I &gt; &amp; <link linkend="_classLUTridiagonalSolver">LUTridiagonalSolver</link>&lt; V, I &gt;::operator= (const <link linkend="_classLUTridiagonalSolver">LUTridiagonalSolver</link>&lt; V, I &gt; &amp; source)</computeroutput></para><para>
Definition at line 120 of file LUSolver.cc.</para>
<programlisting>121 {
122 &#32;&#32;&#32;&#32;
123 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(<emphasis role="keyword">this</emphasis>&#32;==&#32;&amp;source)
124 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;*<emphasis role="keyword">this</emphasis>;
125 
126 &#32;&#32;&#32;&#32;a&#32;=&#32;source.a;
127 &#32;&#32;&#32;&#32;<link linkend="_namespaceNSEuropeanOption_1a6b26f4d79c6b43133be664e2eb229fff">b</link>&#32;=&#32;source.b;
128 &#32;&#32;&#32;&#32;c&#32;=&#32;source.c;
129 &#32;&#32;&#32;&#32;<link linkend="_namespaceNSEuropeanOption_1adf476278b7e6a6960d82dc00e93ef723">r</link>&#32;=&#32;source.r;
130 
131 &#32;&#32;&#32;&#32;Size&#32;=&#32;source.Size;
132 }
</programlisting>    </section><anchor xml:id="_classLUTridiagonalSolver_1aaa85d72ad1cd651291fee595db3fe1d8"/>    <section>
    <title>solve()</title>
<indexterm><primary>solve</primary><secondary>LUTridiagonalSolver&lt; V, I &gt;</secondary></indexterm>
<indexterm><primary>LUTridiagonalSolver&lt; V, I &gt;</primary><secondary>solve</secondary></indexterm>
<computeroutput>template&lt;class V , class I &gt; </computeroutput><para><computeroutput><link linkend="_classVector">Vector</link>&lt; V, I &gt; <link linkend="_classLUTridiagonalSolver">LUTridiagonalSolver</link>&lt; V, I &gt;::solve ( )</computeroutput></para><para>
Definition at line 136 of file LUSolver.cc.</para>
<programlisting>137 {
138 &#32;&#32;&#32;&#32;<emphasis role="comment">//cout&#32;&lt;&lt;&#32;&quot;Solving&#32;&quot;&#32;&lt;&lt;&#32;endl;</emphasis>
139 
140 &#32;&#32;&#32;&#32;calculateBetaGamma();&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Calculate&#32;beta&#32;and&#32;gamma</emphasis>
141 &#32;&#32;&#32;&#32;calculateZU();&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Calculate&#32;z&#32;and&#32;u</emphasis>
142 
143 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;u;
144 &#32;&#32;&#32;&#32;
145 }
</programlisting></section>
<para>
The documentation for this class was generated from the following files:</para>
include/duffy/<link linkend="_LUSolver_8hh">LUSolver.hh</link>src/<link linkend="_LUSolver_8cc">LUSolver.cc</link></section>
</section>
